module Case where

data TT : Type @ 0 where
  tt @ 0

data Box : Type @ 1 where
  box of (TT^1) @ 1

-- This shouldn't fail, and should match on tt as a displaced constructor
h : (P : Box^0 -> Type) -> P (box^0 tt^1) -> (b : Box^0) -> P b
h = \P Pb b. case b of
  box t -> case t of
    tt -> Pb

data X : Type @ 0 where
  c of (Unit) @ 0

-- This should fail, since it normalizes to \P u. P u, which is ill typed.
Pu : (P : (x : Unit @ 0) -> Type) -> (u : Unit @ 1) -> Type
Pu = \P u. case c u of
  c x -> P x