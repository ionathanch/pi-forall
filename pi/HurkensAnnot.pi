module HurkensAnnot where

data Void : Type where {}

P : Type -> Type @ 0
P = \S. S -> Type

U : Type @ 1
U = (x : Type @ 0) -> (P^0 (P^0 x) -> x) -> P^0 (P^0 x)

tau : P^0 (P^0 U^0) -> U^0 @ 1
tau = \t. \x. \f. \p. t (\s. p (f (s x f)))

sigma : U^1 -> P^0 (P^0 U^0) @ 2
sigma = \s. s U^0 tau^0

{-
s : U^1
s : (x:*1) -> (P1 (P1 x) -> x) -> P1 (P1 x)

s U0 : (P1 (P1 U0) -> U0) -> P1 (P1 U0)

tau  : (P0 (P0 U0) -> U0)

NOTE: P1 (P1 U0) = P0 (P0 U0) but *only* after expanding terms
-}

Delta : Type -> P^0 U^1 @ 2
Delta = \b. \y. ((p : P^0 U^0 @ 1) -> sigma^0 y p -> p (tau^0 (sigma^0 y))) -> b

Omega : U^0 @ 3
Omega = tau^0 (\p. (x : U^1 @ 2) -> sigma^0 x p -> p (\y. x y))

M : (x : U^2 @ 3) -> sigma^1 x (Delta^0 Void^0) -> Delta^1 Void^0 x @ 4
M = \x. \two. \three. three (Delta^0 Void^0) two (\p. three (\y. p (tau^0 (sigma^0 y))))

{-
R : (p : P^0 U^0) -> ((x : U^0) -> sigma^0 x p -> p x) -> p Omega^0
R = \zero. \one. one Omega^0 (\x. one (tau^0 (sigma^0 x)))

L : ((p : P^0 U^0) -> ((x : U^0) -> sigma^0 x p -> p x) -> p Omega^0) -> Void^0
L = \zero. zero (Delta^0 Void^0) M (\p. zero (\y. p (tau^0 (sigma^0 y))))

false : Void^0
false = L R
-}
