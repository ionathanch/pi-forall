-- Simple examples demonstrating parametric polymorphism in core language

module Lec1 where

id : (x:Type @ 0) -> x -> x @ 1
id = \x y . y 

idid : ((x:Type @ 0) -> x -> x) @ 2
idid = (\x y. y : (x:Type @ 1) -> x -> x) ((x:Type @ 0) -> x -> x) id

-- needs displacement 
idid2 : ((x:Type @ 0) -> x -> x) @ 2
idid2 = id^1 ((x:Type @ 0) -> x -> x) id

compose : (A : Type @ 0) -> (B : Type @ 0) -> (C:Type @ 0) ->
  (B -> C) -> (A -> B) -> (A -> C) @ 1
compose = \ A B C f g x. (f (g x))

idT : Type @ 1
idT = (x:Type @ 0) -> x -> x

selfapp : idT -> idT @ 1
selfapp = (\x.x : (idT -> idT) -> (idT -> idT)) (\x.x)

-- Church encoding: booleans

true : (A:Type @ 0) -> A -> A -> A @ 1
true = \A x y. x

false : (A:Type @ 0) -> A -> A -> A @ 1
false = \A x y. y

cond : ((A:Type @ 0) -> A -> A -> A) -> (x:Type @ 0) -> x -> x -> x @ 1
cond = \ b . b 

-- void type

void : Type @ 1
void = (x:Type @ 0) -> x

-- inhabited by diverging term

loop : (x:Type @ 0) -> x @ 1
loop = \x. loop x

-- unit type 

unit : Type @ 1
unit = (x:Type @ 0) -> x -> x

-- this code only type checks with a definition of type equality that 
-- includes beta-equivalence/definitions (i.e. >= version2)

-- Church encoding of simply-typed pairs
{-

pair : Type -> Type -> Type
pair = \p. \q. (c: Type) -> (p -> q -> c) -> c

prod : (p:Type) -> (q:Type) -> p -> q -> pair p q
prod = \p.\q. \x.\y. \c. \f. f x y

proj1 : (p:Type) -> (q:Type) -> pair p q -> p
proj1  = \p. \q. \a. a p (\x.\y.x)

proj2 : (p:Type) -> (q:Type) -> pair p q -> q
proj2  = \p. \q. \a. a q (\x.\y.y)

swap : (p:Type) -> (q:Type) -> pair p q -> pair q p
swap = \p. \q. \a. prod q p (proj2 p q a) (proj1 p q a)
-}
