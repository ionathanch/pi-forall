module NatChurchEx where

-- Church encoding of natural numbers
-- with explicit level annotations

nat : Type @ 1
nat = (x:Type @ 0) -> x -> (x -> x) -> x

z : nat @ 1
z = \x zf sf. zf

s : nat -> nat @ 1
s = \n. \x zf sf. sf (n x zf sf)

one : nat @ 1 
one = s z

two : nat @ 1 
two = s (s z)

three : nat @ 1
three = s (s (s z))   -- replace with correct definition of 3

plus : (nat^1) -> (nat^0) -> (nat^0) @ 2   -- need to lift first nat for the instantiation
plus = \x. \y. x (nat^0) y s

{- 

x: nat^1 @ 2 == Pi (x:type @ 1) -> x -> (x -> x) -> x : type
y: nat^0 @ 1 

x nat^0 : (nat^0) -> (nat^0 -> nat^0) -> nat^0

one : nat^0 @ 1
one : nat^1 @ 2

-}

test0 : (plus^1) one one = two @ 3
test0 = Refl

test1 : plus one^1 two = three @ 2
test1 = Refl

spec0 : (n : nat) -> plus z^1 n = n @ 2
spec0 = \n . Refl

spec1 : (n : nat^1) -> (m : nat) -> plus (s^1 n) m  = s (plus n m) @ 3 
spec1 = \n m . Refl

-- The predecessor function is *really* tricky! Don't try this 
-- first if you have never seen it before.

pred : nat -> nat @ 1 
pred = TRUSTME

test_pred : pred two = one @ 2
test_pred = TRUSTME -- replace with Refl

{-
-- Since pi-forall allows recursive definitions, we also have Scott encodings
-- of datatypes available. (See http://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding.
-- You can't do this in Coq or Agda because it requires an inconsistent logic).

scott_nat : Type 
scott_nat = (x:Type) -> x -> (scott_nat -> x) -> x

scott_z : scott_nat
scott_z = \x z s . z

scott_s : scott_nat -> scott_nat
scott_s = \n . \x z s . s n

scott_one : scott_nat
scott_one = scott_s scott_z

scott_two : scott_nat
scott_two = scott_s (scott_s scott_z)

scott_three : scott_nat
scott_three = scott_s (scott_s (scott_s scott_z))

-- Write the predecessor function, it is much easier here

scott_pred : scott_nat -> scott_nat
scott_pred = TRUSTME

testNC1 : scott_pred scott_two = scott_one
testNC1 = TRUSTME -- replace with Refl

-- Now write plus: with Scott encoded nats, note that you need to use recursion.

scott_plus : scott_nat -> scott_nat -> scott_nat 
scott_plus = TRUSTME

testNC2 : scott_plus scott_one scott_two = scott_three
testNC2 = TRUSTME -- replace with Refl
-}