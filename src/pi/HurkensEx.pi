module HurkensEx where
-- Hurkens paradox with explicit level annotations

data Void : Type where {}

neg : Type -> Type @ 0
neg = \X. X -> Void

P : Type -> Type @ 0
P = \S. S -> Type

U : Type @ 1
U = (x : Type @ 0) -> (((P^0) ((P^0) x)) -> x) -> (P^0) ((P^0) x)

tau : ((P^0) ((P^0) (U^0))) -> (U^0) @ 1
tau = \t. \x. \f. \p. t (\s. p (f (s x f)))

sigma : U -> (P^0) ((P^0) (U^0)) @ 2
sigma = \s. s (U^0) (tau^0)

{-

s : U^1
s : (x:*1) -> (P1 (P1 x) -> x) -> P1 (P1 x)

s U0 : (P1 (P1 U0) -> U0) -> P1 (P1 U0)

tau  : (P0 (P0 U0) -> U0)

NOTE:
   P1 (P1 U0) = P0 (P0 U0)
   but *only* after expanding terms
   so we should keep track of which definitions are freely displaceable

-}



Delta : (P^0) U^1 @ 2
Delta = \y. neg ((p : (P^0) (U^0) @ 1) -> (sigma^0) y p -> p ((tau^0) ((sigma^0) y)))

-- warning: parser is not good enough for U^1 @ 2, need to have parens around displaced term

Omega : (U^0) @ 3
Omega = (tau^0) (\p. (x : (U^1) @ 2) -> (sigma^0) x p -> p (\y. x y))

M : (x : (U^2) @ 3) -> sigma^1 x Delta^0 -> Delta^1 x @ 4
M = \x. \two. \three. three Delta^0 two (\p. three (\y. p ((tau^0) ((sigma^0) y))))


{-  -- can't type check
R : (p : (P^0) (U^0)) -> ((x : (U^0)) -> (sigma^0) x p -> p x) -> p (Omega^0)
R = \zero. \one. one (Omega^0) (\x. one ((tau^0) ((sigma^0) x)))
L : neg ((p : (P^0) (U^0)) -> ((x : (U^0)) -> (sigma^0) x p -> p x) -> p (Omega^0))
L = \zero. zero Delta M (\p. zero (\y. p ((tau^0) ((sigma^0) y))))
false : Void
false = L R
-}
