module Lec2 where


-- "large eliminations" 

bool' : Bool -> Type @ 1
bool' = \b . (B : Bool -> Type) -> B True -> B False -> B b

true' : bool' True @ 1
true' = \A x y . x

false' : bool' False @ 1
false' = \ A x y. y

T : Bool -> Type
T = \b. if b then Unit else Bool

z1 : T True
z1 = ()

z2 : T False
z2 = True


-- To get bar and barnot to work 
-- the typing rule for 'if' expressions must be 
-- context-dependent. In otherwords, it should add new 
-- definitions to the context in the true/false branches
-- when the scrutinee is a variable
-- (i.e. >= version2)


not : Bool -> Bool 
not = \x. if x then False else True

bar : (b : Bool) -> T b @ 1
bar = \b. if b then () else True

barnot : (b : Bool) -> T (not b)  @ 1
barnot = \b. if b then False else ()


-- projections for sigma types

fst : (A:Type) -> (B : A -> Type) -> { x2 : A | B x2 } -> A  @ 2
fst = \A B p. let (x,y) = p in x

snd : (A:Type) -> (B : A -> Type) -> (p : { x2 : A | B x2 } @ 1) -> B (fst A B p) @ 2
snd = \A B p. let (x1,y) = p in y

-- examples of propositional equality

sym : (A:Type @ 1) -> (x:A) -> (y:A) -> (x = y) -> y = x @ 2
sym = \ A x y pf .
  subst Refl by pf 

