{- Adapted from https://vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive/ -}

module Reynolds where
import Logic

Phi : Type -> Type
Phi = \S. (S -> Type) -> Type

-- Basic manipulations of equality

cong : [A : Type] -> [B : Type] -> [x : A] -> [y : A] -> [f : A -> B] -> x = y -> f x = f y
cong = \[A]. \[B]. \[x]. \[y]. \[f]. \h. subst Refl by h

transp : [A : Type] -> [B : A -> Type] -> [x : A] -> [y : A] -> x = y -> B x -> B y
transp = \[A]. \[B]. \[x]. \[y]. \h. \Bx. subst Bx by h

-- Our non-strictly positive datatype and some injectivity lemmas

data Bad : Type where
  MkBad of (Phi Bad)

f : (Bad -> Type) -> Bad
f = \x. MkBad (\z. z = x)

badInj : (x : Phi Bad @ 1) -> (y : Phi Bad @ 1) -> MkBad x = MkBad y -> x = y
badInj = \x. \y. \h.
  cong [Bad] [Phi Bad] [MkBad x] [MkBad y]
       [\bad. case bad of MkBad z -> z] h

-- MkBad (_= x) = MkBad (_= y) ---[badInj]--> (_= x) = (_= y) ---[transp]--> (x = x) -> (x = y)
fInj : (x : Bad -> Type @ 1) -> (y : Bad -> Type @ 1) -> f x = f y -> x = y
fInj = \x. \y. \h.
  transp [Phi Bad] [\f. f x] [\z. z = x] [\z. z = y]
         (badInj (\z. z = x) (\z. z = y) h) Refl

-- Russell's paradox

P0 : Bad -> Type
P0 = \x. {P : Bad -> Type | And (x = f P) (neg (P x)) }

bad : Bad
bad = f P0

lem1 : neg (P0 bad)
lem1 = \p. let (P , hn) = p in
  case hn of
    Conj h n -> n (subst p by fInj P0 P h)
    -- h : f P0 = f P
    -- n : neg (P bad)
    -- fInj P0 P badfp : P0 = P

{-
lem2 : neg (P0 bad) -> P0 bad
lem2 = \np. PRINTME -- (P0 , Conj Refl np)

false : Void
false = lem1 (lem2 lem1)
-}